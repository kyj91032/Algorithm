# https://boj-helper.vercel.app/solve/1463?language=python

# 생각 과정
'''
완전탐색 시도 -> 3나누기, 2나누기, 1빼기 많은 조합이 나올 것 같음 -> 이전 결과값을 활용할 수 있으면 dp로 풀 수 있을 것 같음
i는 주어진 수, d[i]는 i를 1로 만드는 최소 연산 횟수로 정의
점화식은 일반식부터 d[i] = min(d[i-1] + 1, d[i / 3] + 1, d[i / 2] + 1)
구체적으로는 최소값을 갱신하면서 진행
'''

# 풀이 코드
n = int(input())

inf = 1e9

d = [inf] * (1000001)

d[1] = 0
d[2] = 1
d[3] = 1

if n <= 3:
    print(d[n])
else:
    for i in range(4, n+1):
        # d[i] 는 3 나누기 전, 2나누기전, 1빼기 전 3가지 중 min 을 하면 됨
        # d[i] = min(d[i-1] + 1, d[i / 3] + 1, d[i / 2] + 1)
        # 여기서 나누기 시에는 나머지가 0인지 확인해줘야함

        # 이 부분을 if else로 분기하면 안됨. if를 따로 둬서 모두 실행될 수 있도록 해야함
        if i % 3 == 0: # 3으로 나눈 후
            d[i] = min(d[i], d[i // 3] + 1) 
        if i % 2 == 0: # 5로 나눈 후
            d[i] = min(d[i], d[i // 2] + 1)
        d[i] = min(d[i], d[i-1] + 1) # 1을 뺀 후

    print(d[n])


# 피드백 후 정리

'''
1. 완전탐색의 가지가 많고, 이전 결과값을 활용할 수 있으면 dp로 풀기
2. d[i] = min(d[i-1] + 1, d[i / 3] + 1, d[i / 2] + 1, d[i])와 같은 min, max 함수를 활용하는 유형에서
   자기 자신을 포함한 경우도 고려해야 함. 한줄씩 진행하면서 최소값을 갱신해나가는 방식
'''